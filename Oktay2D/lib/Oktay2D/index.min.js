/**
 *  =========================== Oktay2D ===========================
 *  
 *  A graphics library for the web made by Babah Gee.
 * 
 *  Version 1.0.0 - Last edited: 10-02-2022
 */
import { log as e } from "./essentials/debugger.js"; import { generateUniqueID as t } from "./essentials/generateUniqueId.js"; import { RandomBetween as n } from "./essentials/math.js"; import { RenderObject as s, RenderObjects as i } from "./essentials/renderobject.js"; import { Camera as r } from "./rendering/camera.js"; export const _LIB_OPTIONS = { _USABLE_FLAGS: [], _USER_AGENT: navigator.userAgent, _PLATFORM: "string" == typeof navigator.platform ? navigator.platform : null, _POST_PROCESSING_SHADERS: ["SHADER_AMBIENT_OCCLUSION", "SHADER_BLOOM"], _MODULE_LOADER: "undefined" != typeof require ? { __ELECTRON: require("electron"), __JS_EASINGS: require("js-easing-functions"), __SAT_PHYSICS: require("sat") } : null, _FILTER_USAGE: !0, _CHECK_FLAG_STATE: function (e) { if ("new-canvas-2d-api" === e) { let e = !0; return { __NEW_CANVAS_API: ["roundRect", "createConicGradient", "reset"] }.__NEW_CANVAS_API.forEach((t => { void 0 === CanvasRenderingContext2D.prototype[t] && (e = !1) })), e } } };
// Type definitions 
/**
* @typedef CanvasSceneMouseButtons
* @property {boolean} right
* @property {boolean} middle
* @property {boolean} left
*/
/**
* @typedef CanvasSceneMouseProperties
* @property {number} x
* @property {number} y
* @property {number} velocityX
* @property {number} velocityY
* @property {number} lastTimeStamp
* @property {number} wheelDirection
* @property {boolean} isInWindow
* @property {CanvasSceneMouseButtons} buttons
*/
/**
 * @typedef LinearGradientColorStopDefinitions
 * @property {number} offset
 * @property {string} color
 */export class CanvasScene {
    #e = {};
    /**
         * Creates a new Canvas Scene
         * @param {number} width
         * @param {number} height
         * @param {HTMLElement} domElement
         * @example
         * new CanvasScene(520, 840, document.body);
         */
    constructor(t, n, s) {
        if ("number" != typeof t) throw new Error("The given argument (as width) is not a number."); if ("number" != typeof n) throw new Error("The given argument (as height) is not a number."); if (!(s instanceof HTMLElement)) throw new Error("The given argument (as domElement) is not a HTMLElement instance."); this.width = t, this.height = n, this.domElement = s, this.attributes = [], this.mouse = { x: 0, y: 0, velocityY: 0, velocityX: 0, lastTimestamp: 0, wheelDirection: null, buttons: { left: !1, middle: !1, right: !1 }, isInWindow: !1 }, e("CanvasScene", "Initializing canvas scene...", "color: yellow");
        // Create the element.
        const i = document.createElement("canvas"); i.className = "oktay2d-scene", i.width = this.width, i.height = this.height, i.setAttribute("crossOrigin", "anonymous"), s.appendChild(i), this.canvas = i, window.addEventListener("resize", (() => { this.HandleResizeEvent() })), this.HandleEvents(), e("CanvasScene", "Succesfully initialized canvas scene.", "color: lime;")
    } HandleEvents() {
        // Mouse move event
        this.canvas.addEventListener("mousemove", (e => { const t = performance.now(), n = t - this.mouse.lastTimestamp, s = Math.abs(e.offsetX - this.mouse.x), i = Math.round(s / n * 1e3), r = Math.abs(e.offsetY - this.mouse.y), a = Math.round(r / n * 1e3); this.mouse.velocityX = i, this.mouse.velocityY = a, this.mouse.x = e.offsetX, this.mouse.y = e.offsetY, this.mouse.lastTimestamp = t, "function" == typeof this.#e.mouseMove && this.#e.mouseMove(this.mouse, this) })),
            // Mouse down event.
            this.canvas.addEventListener("mousedown", (e => { switch (e.button) { case 0: this.mouse.buttons.left = !0; break; case 1: this.mouse.buttons.middle = !0; break; case 2: this.mouse.buttons.right = !0 }"function" == typeof this.#e.mouseDown && this.#e.mouseDown(this.mouse, this) })),
            // Mouse up event.
            this.canvas.addEventListener("mouseup", (e => { switch (e.button) { case 0: this.mouse.buttons.left = !1; break; case 1: this.mouse.buttons.middle = !1; break; case 2: this.mouse.buttons.right = !1 }"function" == typeof this.#e.mouseUp && this.#e.mouseUp(this.mouse, this) })),
            // Mouse out event.
            this.canvas.addEventListener("mouseout", (e => { this.mouse.x = 0, this.mouse.y = 0, this.mouse.isInWindow = !1, "function" == typeof this.#e.mouseOut && this.#e.mouseOut(this.mouse, this) })),
            // Mouse enter event.
            this.canvas.addEventListener("mouseenter", (e => { this.mouse.isInWindow = !0, "function" == typeof this.#e.mouseEnter && this.#e.mouseEnter(this.mouse, this) })),
            // Mouse wheel event.
            this.canvas.addEventListener("wheel", (e => { e.deltaY < 0 && (this.mouse.wheelDirection = "top"), e.deltaY > 0 && (this.mouse.wheelDirection = "down"), e.deltaX < 0 && (this.mouse.wheelDirection = "left"), e.deltaX > 0 && (this.mouse.wheelDirection = "right"), "function" == typeof this.#e.mouseWheel && this.#e.mouseWheel(this.mouse, this) }))
    } HandleResizeEvent() { if ("function" == typeof this.#e.sceneResize && this.#e.sceneResize(this), this.attributes.includes("fitToScreen") && (this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight, this.width = window.innerWidth, this.height = window.innerHeight), this.attributes.includes("redrawOnResize")) { let e = 0; for (; e < i.length;) { const t = i[e]; "function" == typeof t.Draw && t.Draw(this.appliedRenderer.ctx), e += 1 } } }
/**
     * Sets the size of the canvas element.
     * @param {number | null} width
     * @param {number | null} height
     * @returns {this}
     */SetSize(e, t) { return "number" == typeof e && (this.width = e, this.canvas.width = e), "number" == typeof t && (this.height = t, this.canvas.height = t), this }
/**
     * Sets an attribute on the canvas element.
     * @param {"fitToScreen" | "disableContextMenu" | "redrawOnResize"} attribute
     */SetAttribute(e) { if ("string" != typeof e) throw new Error("The given argument (as attribute) is not a string."); if (this.attributes.includes(e)) throw new Error(`Cannot set attribute '${e}' because it as already been set on this instance.`); switch (e) { case "fitToScreen": case "redrawOnResize": this.attributes.push(e); break; case "disableContextMenu": this.canvas.addEventListener("contextmenu", (function (e) { e.preventDefault() })), this.attributes.push(e); break; default: throw new Error(`The given attribute '${e}' is not a recognized attribute for this instance.`) } }
/**
     * Will export the canvas data to an image.
     * @param {("png" | "webp" | "jpeg" | "jpg")} format Image format
     * @returns {string | null}
     */ExportToImage(e) { return void 0 === e ? this.canvas.toDataURL() : this.canvas.toDataURL("image/" + e) }
/**
     * @callback eventCallback
     * @param {CanvasSceneMouseProperties} mouse
     * @param {CanvasScene} self
     */
/**
     * Event listener.
     * @param {"sceneResize" | "mouseDown" | "mouseUp" | "mouseMove" | "mouseOut" | "mouseEnter" | "mouseWheel"} event
     * @param {eventCallback} callback
    */On(e, t) { let n = ["sceneResize", "mouseDown", "mouseUp", "mouseMove", "mouseOut", "mouseEnter", "mouseWheel"], s = !1; for (let t in n) n[t] === e && (s = !0); if (!s) throw new Error(`The given event name '${e}' is not a valid event for this instance.`); if ("function" != typeof t) throw new Error("The given argument (as callback) is not a function."); this.#e[e] = t }
} export class Renderer {
    /**@type {CanvasScene} */
    scene;
    /**@type {Array} */
    attributes;
    /**@type {Array} */
    renderObjects;
    /**@type {CanvasRenderingContext2D} */
    ctx;
    /**@type {Camera} */
    camera;
    /**@type {number} */
    visibleObjects;
    /**
         * @typedef {Object} RendererAttributes
         */
    /**
         * Creates a new canvas2d renderings context.
         * @param {CanvasScene} scene CanvasScene instance to draw the graphics on.
         * 
         * @param {object} attributes Rendering attributes to specify different settings.
         * @param attributes.alpha {boolean}
         * @param attributes.willReadFrequently {boolean}
         * @param attributes.desynchronized {boolean}
         */
    constructor(e, t) {
        if (!(e instanceof CanvasScene)) throw new Error("The given argument (as scene) is not a CanvasScene instance."); this.scene = e, this.attributes = t,
            /**@type {Array.<RenderObject>} */
            this.renderObjects = [], this.ctx = e.canvas.getContext("2d", t), this.ctx.com, this.globalTransformation = null, this.camera = null, e.appliedRenderer = this
    } UpdateCamera(e, t) { this.ctx.beginPath(), this.ctx.translate(e, t) }
/** Saving the current canvas rendering state. */SaveState() { return this.ctx.save(), this }
/**Restores the last saved canvas rendering state. */RestoreState() { return this.ctx.restore(), this }
/**
     * Sets a background color.
     * @param {string} color
     */SetBackgroundColor(e) { const t = this.ctx, n = this.scene; return t.save(), t.beginPath(), t.rect(0, 0, n.width, n.height), t.fillStyle = e, t.fill(), t.closePath(), t.restore(), this }
/**Renders all objects added to this renderer. */RenderAllObjects(e) {
        const t = this.ctx; if (this.camera instanceof r) {
            // Handle camera events.
            t.save(),
                // Global tranformation
                null !== this.globalTransformation && t.transform(this.globalTransformation.horizontalScaling, this.globalTransformation.verticalSkewing, this.globalTransformation.horizontalSkewing, this.globalTransformation.verticalScaling, this.globalTransformation.horizontalTranslation, this.globalTransformation.verticalTranslation), t.translate(this.camera.x, this.camera.y), t.scale(this.camera.scaleX, this.camera.scaleY); let n = 0, s = 0; for (; n < this.renderObjects.length;) {
                    /**@type {RenderObject} */
                    const t = this.renderObjects[n]; this.camera.offscreenRendering ? ("function" == typeof t.Draw && t.Draw(this.ctx), "function" == typeof t.Update && t.Update(this.ctx, e)) : "number" == typeof t.width && "number" == typeof t.height && (t.x > -((this.camera.x + 30) / this.camera.scaleX + t.width) && t.x < -(this.camera.x - this.camera.width) / this.camera.scaleX && t.y > -(this.camera.y + 30) / this.camera.scaleY && t.y < -(this.camera.y - this.camera.height) / this.camera.scaleY ? (s += 1, t.visible = !0, "function" == typeof t.Draw && t.Draw(this.ctx), "function" == typeof t.Update && t.Update(this.ctx, e)) : t.visible = !1), n += 1
                }
            // this.RenderFilter();
            return this.visibleObjects = s, t.restore(), this
        } {
            t.save(),
            // Global tranformation
            null !== this.globalTransformation && t.transform(this.globalTransformation.horizontalScaling, this.globalTransformation.verticalSkewing, this.globalTransformation.horizontalSkewing, this.globalTransformation.verticalScaling, this.globalTransformation.horizontalTranslation, this.globalTransformation.verticalTranslation); let n = 0; for (; n < this.renderObjects.length;) {
                /**@type {RenderObject} */
                const t = this.renderObjects[n]; "function" == typeof t.Draw && t.Draw(this.ctx), "function" == typeof t.Update && t.Update(this.ctx, e), n += 1
            } return t.restore(), this
        }
    }
/**
     * Renders an object in this renderer instance.
     * @param {RenderObject} renderObject
     */Render(e, t) { if (!(e instanceof s)) return void this.RenderAllObjects(t); const n = this.ctx; n.save(), n.translate(this.camera.x, this.camera.y), "function" == typeof e.Draw && e.Draw(this.ctx), n.restore() }
/**Clears the entire screen */ClearScene() { return this.ctx.clearRect(0, 0, this.scene.width, this.scene.height), this }
/**
     * Adds a renderobject to this instance. Can be useful when having multiple renderers and wants to render a specific one instead of all render objects.
     * @param {RenderObject | Array<RenderObject>} renderObject
     */Add(e) { if (!(e instanceof s || e instanceof Array)) throw new Error("Cannot add instance since it's not a RenderObject."); if (e instanceof s) return this.renderObjects.push(e), e.appliedRenderContext = this.ctx, this; if (e instanceof Array) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (!(n instanceof s)) throw new Error(`The item in given array with index number '${t}' is not a RenderObject instance.`); n.appliedRenderContext = this.ctx, this.renderObjects.push(n) } return this } }
/**
     * Removes a RenderObject instance from this renderer.
     * @param {RenderObject} renderObject
     */Remove(e) { if (!(e instanceof s)) throw new Error("The given argument is not a RenderObject instance."); let t = 0; for (; t < this.renderObjects.length;) { if (this.renderObjects[t].id === e.id) { this.renderObjects.splice(t, 1), t = this.renderObjects.length - 1; break } t += 1 } }
/**
    * Sets a global transformation matrix.
    * @param {number} horizontalScaling Horizontal scaling. A value of '1' results in no scaling.
    * @param {number} verticalSkewing Vertical skewing.
    * @param {number} horizontalSkewing Horizontal skewing.
    * @param {number} verticalScaling Vertical scaling. A value of '1' results in no scaling.
    * @param {number} horizontalTranslation Horizontal translation.
    * @param {number} verticalTranslation Vetical translation.
    */SetGlobalTranformation(e, t, n, s, i, r) { return null === e ? (this.globalTransformation = null, this) : (this.globalTransformation = { horizontalScaling: e, verticalSkewing: t, horizontalSkewing: n, verticalScaling: s, horizontalTranslation: i, verticalTranslation: r }, this.globalTransformation) } RenderFilter() { const e = this.ctx; e.beginPath(); const t = e.getImageData(0, 0, this.scene.width, this.scene.height); for (let e = 0; e < t.data.length; e += 4) { const s = t.data; let i = s[e], r = s[e + 1], a = s[e + 2], o = s[e + 3]; i = n(i - 10, i + 10), t.data[e] = i, t.data[e + 1] = r, t.data[e + 2] = a, t.data[e + 3] = o } e.putImageData(t, 0, 0) }
/**
     * Creates a linear gradient object.
     * @param {number} x0 The x-axis coordinate of the start point.
     * @param {number} y0 The y-axis coordinate of the start point.
     * @param {number} x1 The x-axis coordinate of the end point.
     * @param {number} y1 The y-axis coordinate of the end point.
     * @param {Array<LinearGradientColorStopDefinitions>} colorStops Color stops.
     */CreateLinearGradient(e, t, n, s, i) { if ("number" != typeof e) throw new Error("The x-axis coordinate of the start point has not been specified as a number."); if ("number" != typeof t) throw new Error("The y-axis coordinate of the start point has not been specified as a number."); if ("number" != typeof n) throw new Error("The x-axis coordinate of the end point has not been specified as a number."); if ("number" != typeof s) throw new Error("The y-axis coordinate of the end point has not been specified as a number."); if (!(this.ctx instanceof CanvasRenderingContext2D)) throw new Error("Failed to generate a linear gradient object since no CanvasRenderingContext2D has been defined."); const r = this.ctx.createLinearGradient(e, t, n, s); for (var a = 0; a < i.length; a++) { const e = i[a]; "number" == typeof e.offset && "string" == typeof e.color && r.addColorStop(e.offset, e.color) } return r }
/**
     * Creates a radial gradient using the size and coordinates of two circles.
     * For example:
     * 
     * Renderer.CreateRadialGradient(50, 50, 0, 100, 100, 50);
     * 
     * @param {number} x0 The x-axis coordinate of the start circle.
     * @param {number} y0 The y-axis coordinate of the start circle.
     * @param {number} r0 The radius of the start circle. Must be non-negative and finite.
     * @param {number} x1 The x-axis coordinate of the end circle.
     * @param {number} y1 The y-axis coordinate of the end circle.
     * @param {number} r1 The radius of the end circle. Must be non-negative and finite.
     * @param {Array<LinearGradientColorStopDefinitions>} colorStops Color stops.
     */CreateRadialGradient(e, t, n, s, i, r, a) { if ("number" != typeof e) throw new Error("The x-axis coordinate of the start circle has not been specified as a number."); if ("number" != typeof t) throw new Error("The y-axis coordinate of the start circle has not been specified as a number."); if ("number" != typeof n) throw new Error("The radius of the start circle has not been specified as a number."); if ("number" != typeof s) throw new Error("The x-axis coordinate of the end circle has not been specified as a number."); if ("number" != typeof i) throw new Error("The y-axis coordinate of the end circle has not been specified as a number."); if ("number" != typeof r) throw new Error("The radius of the end circle has not been specified as a number."); if (!(this.ctx instanceof CanvasRenderingContext2D)) throw new Error("Failed to generate a linear gradient object since no CanvasRenderingContext2D has been defined."); const o = this.ctx.createRadialGradient(e, t, n, s, i, r); for (var h = 0; h < a.length; h++) { const e = a[h]; "number" == typeof e.offset && "string" == typeof e.color && o.addColorStop(e.offset, e.color) } return o } CreateConicGradient() { }
} export class SceneUpdater {
    /**@type {string} */
    id;
    /**@type {Renderer} */
    renderer;
    /**@type {AnimationFrameProvider} */
    animationFrame;
    /**@type {number} */
    fps;
    /**@type {Array} */
    times;
    /**@type {number} */
    deltaTime;
    /**@type {Object} */
    events;
    /**@type {number} */
    lastTimestamp;
    /**@type {number} */
    perfrectFrameRate;
    /**
         * Creates a new scene updater. This instance creates a animation loop which will call itself each possible frame.
         * @param {Renderer} renderer
         */
    constructor(e) { if (!(e instanceof Renderer)) throw new Error("The given argument (as renderer) is not a Renderer instance."); this.id = t(18), this.renderer = e, this.animationFrame = null, this.fps = 0, this.times = [], this.deltaTime = 0, this.lastTimestamp = performance.now(), this.perfrectFrameRate = 60, this.events = { onUpdate: [] } } Update(e) { this.animationFrame = window.requestAnimationFrame((e => this.Update(e))); const t = performance.now(); this.deltaTime = (t - this.lastTimestamp) / (1e3 / this.perfrectFrameRate), this.lastTimestamp = t; for (let e = 0; e < this.events.onUpdate.length; e++) { let t = this.events.onUpdate[e]; "function" == typeof t && t(this.deltaTime) } for (void 0 !== this.renderer && this.renderer.Render(null, this.deltaTime); this.times.length > 0 && this.times[0] <= t - 1e3;)this.times.shift(); this.times.push(t), this.fps = this.times.length }
/**
     * Creates an event for this instance. Callback function will be called when a specific event got fired.
     * @param {"update"} event
     * @param {Function} callback
     */On(e, t) { if ("string" != typeof e) throw new Error("The given argument (as event) is not a string."); if (!(t instanceof Function)) throw new Error("The given argument (as callback) is not a function."); if ("update" !== e) throw new Error(`The given event name '${e}' is not a recognized event for this instance.`); this.events.onUpdate.push(t) }
}
/**
 * Waits for a specific time to continue executing code in a codeblock.
 * @param {number} milliseconds
 */export async function WaitFor(e) { if ("number" != typeof e) throw new Error("The given argument (as milliseconds) is not a number."); return new Promise((function (t, n) { setTimeout(t, e) })) }
/**
 * Allows Oktay2D to use features from different flags.
 * @param {"new-canvas-2d-api"} flagName
 */export function SetFlag(e) { return "new-canvas-2d-api" !== e || _LIB_OPTIONS._USABLE_FLAGS.includes(e) ? null : _LIB_OPTIONS._CHECK_FLAG_STATE(e) ? (_LIB_OPTIONS._USABLE_FLAGS.push(e), console.warn(`Flag '${e}' succesfully has been set for Oktay2D. More features will be unlocked, but be careful when using it in production.\n\nSome features may not be available: \n- 4x4 matrices.\n- CanvasFilter class.`), e) : void console.warn(`Failed to set flag '${e}'.`) }
// Exporting rendering things.
export { Camera } from "./rendering/camera.js"; export { FrameCapturer } from "./rendering/canvasEncoder.js";
// Export audio things.
export { AudioNode } from "./audio/audioNode.js"; export { DynamicAudioController } from "./audio/dynamicAudio.js";
// Exporting essentials.
export { Color, ColorNode, LinearGradientColorNode } from "./essentials/color.js";
// export * as Math from "./essentials/math.js";
export { GetInputDown, GetInputUp, keyCodes, activeKeys } from "./essentials/keyboard.js"; export { GamePad, ConnectedGamePads } from "./essentials/gamepad.js"; export { AnimateSingleInteger } from "./essentials/animator.js"; export { CutImageToSprites, SpritesheetAnimator, CutEntireImageToSprites, SpritesheetAnimationController } from "./essentials/spritesheet.js"; export { LoadImageSync } from "./essentials/loader.js";
// Exporting graphical elements.
export { Rectangle } from "./graphics/rectangle.js"; export { Circle } from "./graphics/circle.js"; export { TextNode } from "./graphics/text.js"; export { ParticleSystem } from "./graphics/particleSystem.js"; export { Line, QuadraticCurve } from "./graphics/line.js";
// Exporting controllers.
export { PhysicsController } from "./controllers/physicsController.js";
// Export... uhh... idfk what type of things these are.
export { s as RenderObject, t as generateUniqueID };
// export * as Filters from "./rendering/filter.js";
//# sourceMappingURL=index.min.js.map